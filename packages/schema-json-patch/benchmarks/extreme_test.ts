import { generatePatches } from '../src/patchGenerator.js';
import { Schema } from '../src/types/schema.js';

const generateTestData = (size: number) => {
    const items = [];
    for (let i = 0; i < size; i++) {
        items.push({
            id: `item_${i}`,
            name: `Item ${i}`,
            description: `Description for item ${i}`,
            value: i * 100,
        });
    }
    return items;
};

const testSchema: Schema = {
    $type: 'array',
    $item: {
        $type: 'object',
        $pk: 'id',
        $fields: {
            id: { $type: 'string' },
            name: { $type: 'string' },
            description: { $type: 'string' },
            value: { $type: 'number' },
        },
    },
};

// Fisher-Yates shuffle
const shuffle = <T>(arr: T[]): T[] => {
    const result = [...arr];
    for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
};

console.log('\nğŸ”€ é¡ºåºå˜åŒ–åœºæ™¯æ€§èƒ½æµ‹è¯•\n');
console.log('æµ‹è¯•é¡¹ç›®å®Œå…¨æ‰“ä¹±é¡ºåºçš„æƒ…å†µï¼ˆè§¦å‘ order detectionï¼‰');
console.log('-'.repeat(80));

const sizes = [10, 50, 100, 200, 500, 1000];
let baseTimePerItem = 0;

console.log('Size\t| Time (ms)\t| Time per item (Î¼s)\t| Scaling factor');
console.log('-'.repeat(60));

for (const size of sizes) {
    const source = generateTestData(size);
    const target = shuffle(generateTestData(size)); // å®Œå…¨æ‰“ä¹±é¡ºåº
    const sourceJson = JSON.stringify(source);
    const targetJson = JSON.stringify(target);

    // Warmup
    for (let i = 0; i < 3; i++) {
        generatePatches(testSchema, sourceJson, targetJson);
    }

    // Measure
    const iterations = Math.max(5, Math.floor(500 / size));
    const start = performance.now();
    for (let i = 0; i < iterations; i++) {
        generatePatches(testSchema, sourceJson, targetJson);
    }
    const elapsed = performance.now() - start;

    const avgTime = elapsed / iterations;
    const timePerItem = (avgTime * 1000) / size;

    if (size === 10) baseTimePerItem = timePerItem;
    const scalingFactor = timePerItem / baseTimePerItem;

    console.log(
        `${size}\t| ${avgTime.toFixed(2)}\t\t| ${timePerItem.toFixed(2)}\t\t\t| ${scalingFactor.toFixed(2)}x`
    );
}

console.log('\nğŸ“Š å¤§é‡å˜æ›´åœºæ™¯æµ‹è¯•\n');
console.log('æµ‹è¯•å¤§é‡å…ƒç´ éƒ½å‘ç”Ÿä¿®æ”¹çš„æƒ…å†µ');
console.log('-'.repeat(80));

let baseTimePerItem2 = 0;
console.log('Size\t| Time (ms)\t| Time per item (Î¼s)\t| Scaling factor');
console.log('-'.repeat(60));

for (const size of sizes) {
    const source = generateTestData(size);
    // ä¿®æ”¹æ‰€æœ‰å…ƒç´ 
    const target = source.map(item => ({
        ...item,
        name: `Updated ${item.name}`,
        value: item.value + 1,
    }));
    const sourceJson = JSON.stringify(source);
    const targetJson = JSON.stringify(target);

    // Warmup
    for (let i = 0; i < 3; i++) {
        generatePatches(testSchema, sourceJson, targetJson);
    }

    // Measure
    const iterations = Math.max(5, Math.floor(500 / size));
    const start = performance.now();
    for (let i = 0; i < iterations; i++) {
        generatePatches(testSchema, sourceJson, targetJson);
    }
    const elapsed = performance.now() - start;

    const avgTime = elapsed / iterations;
    const timePerItem = (avgTime * 1000) / size;

    if (size === 10) baseTimePerItem2 = timePerItem;
    const scalingFactor = timePerItem / baseTimePerItem2;

    console.log(
        `${size}\t| ${avgTime.toFixed(2)}\t\t| ${timePerItem.toFixed(2)}\t\t\t| ${scalingFactor.toFixed(2)}x`
    );
}

console.log('\nâœ… å¦‚æœ Scaling factor ä¿æŒ < 2xï¼Œæ€§èƒ½æ˜¯å¯æ¥å—çš„');
console.log('âŒ å¦‚æœ Scaling factor > 2x ä¸”æŒç»­å¢é•¿ï¼Œå­˜åœ¨éçº¿æ€§æ€§èƒ½é—®é¢˜\n');
